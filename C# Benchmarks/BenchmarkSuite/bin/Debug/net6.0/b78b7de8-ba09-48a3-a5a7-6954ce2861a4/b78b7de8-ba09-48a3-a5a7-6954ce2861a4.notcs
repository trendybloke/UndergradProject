
#define NO_ACK
// <auto-generated />

// this file must not be importing any namespaces
// we should use full names everywhere to avoid any potential naming conflicts, example: #1007, #778

// the namespace name must be in sync with WindowsDisassembler.BuildArguments
namespace BenchmarkDotNet.Autogenerated
{
    public class UniqueProgramName // we need different name than typical "Program" to avoid problems with referencing "Program" types from benchmarked code, #691
    {
        
        public static System.Int32 Main(System.String[] args)
        {
            // this method MUST NOT have any dependencies to BenchmarkDotNet and any other external dlls! (CoreRT is exception from this rule)
            // otherwise if LINQPad's shadow copy is enabled, we will not register for AssemblyLoading event
            // before .NET Framework tries to load it for this method
#if NETFRAMEWORK
            using(new DirtyAssemblyResolveHelper())
#endif
                return AfterAssemblyLoadingAttached(args);
        }

        private static System.Int32 AfterAssemblyLoadingAttached(System.String[] args)
        {
            BenchmarkDotNet.Engines.IHost host = // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it
#if WASM || NO_ACK
            new BenchmarkDotNet.Engines.NoAcknowledgementConsoleHost(System.Console.Out);
#else
            new BenchmarkDotNet.Engines.ConsoleHost(System.Console.Out, new System.IO.StreamReader(System.Console.OpenStandardInput(), System.Text.Encoding.UTF8));
#endif

            // the first thing to do is to let diagnosers hook in before anything happens
            // so all jit-related diagnosers can catch first jit compilation!
            BenchmarkDotNet.Engines.HostExtensions.BeforeAnythingElse(host);

            try
            {
                // we are not using Runnable here in any direct way in order to avoid strong dependency Main<=>Runnable
                // which could cause the jitting/assembly loading to happen before we do anything
                // we have some jitting diagnosers and we want them to catch all the informations!!

                // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it
                System.String benchmarkName = System.Linq.Enumerable.FirstOrDefault(System.Linq.Enumerable.Skip(System.Linq.Enumerable.SkipWhile(args, arg => arg != "--benchmarkName"), 1)) ?? "not provided";
                System.Int32 id = args.Length > 0
                    ? System.Int32.Parse(args[args.Length - 1]) // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it
                    : 0; // used when re-using generated exe without BDN (typically to repro a bug)

                if (args.Length == 0)
                {
                    host.WriteLine("You have not specified benchmark id (an integer) so the first benchmark will be executed.");
                }

#if NATIVEAOT
                
#else
                System.Type type = typeof(BenchmarkDotNet.Autogenerated.UniqueProgramName).Assembly.GetType($"BenchmarkDotNet.Autogenerated.Runnable_{id}");
                type.GetMethod("Run", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static).Invoke(null, new System.Object[] { host, benchmarkName });
#endif
                return 0;
            }
            catch (System.Exception oom) when (oom is System.OutOfMemoryException || oom is System.Reflection.TargetInvocationException reflection && reflection.InnerException is System.OutOfMemoryException)
            {
                host.WriteLine();
                host.WriteLine("OutOfMemoryException!");
                host.WriteLine("BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects.");
                host.WriteLine("If your benchmark allocates memory and keeps it alive, you are creating a memory leak.");
                host.WriteLine("You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that.");
                host.WriteLine();
                host.WriteLine(oom.ToString());

                return -1;
            }
            catch(System.Exception ex)
            {
                host.WriteLine();
                host.WriteLine(ex.ToString());
                return -1;
            }
            finally
            {
                BenchmarkDotNet.Engines.HostExtensions.AfterAll(host);
            }
        }
    }

#if NETFRAMEWORK
    internal class DirtyAssemblyResolveHelper : System.IDisposable
    {
        internal DirtyAssemblyResolveHelper() => System.AppDomain.CurrentDomain.AssemblyResolve += HelpTheFrameworkToResolveTheAssembly;

        public void Dispose() => System.AppDomain.CurrentDomain.AssemblyResolve -= HelpTheFrameworkToResolveTheAssembly;

        /// <summary>
        /// according to https://msdn.microsoft.com/en-us/library/ff527268(v=vs.110).aspx
        /// "the handler is invoked whenever the runtime fails to bind to an assembly by name."
        /// </summary>
        /// <returns>not null when we find it manually, null when can't help</returns>
        private System.Reflection.Assembly HelpTheFrameworkToResolveTheAssembly(System.Object sender, System.ResolveEventArgs args)
        {
#if SHADOWCOPY // used for LINQPad
            const System.String shadowCopyFolderPath = @"";

            System.String guessedPath = System.IO.Path.Combine(shadowCopyFolderPath, $"{new System.Reflection.AssemblyName(args.Name).Name}.dll");

            return System.IO.File.Exists(guessedPath) ? System.Reflection.Assembly.LoadFrom(guessedPath) : null;
#else
            System.Reflection.AssemblyName fullName = new System.Reflection.AssemblyName(args.Name);
            System.String simpleName = fullName.Name;

            System.String guessedPath = System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, $"{simpleName}.dll");

            if (!System.IO.File.Exists(guessedPath))
            {
                System.Console.WriteLine($"// Wrong assembly binding redirects for {args.Name}.");
                return null; // we can't help, and we also don't call Assembly.Load which if fails comes back here, creates endless loop and causes StackOverflow
            }

            // the file is right there, but has most probably different version and there is no assembly binding redirect or there is a wrong one...
            // so we just load it and ignore the version mismatch

            // we warn the user about that, in case some Super User want to be aware of that
            System.Console.WriteLine($"// Wrong assembly binding redirects for {simpleName}, loading it from disk anyway.");

            return System.Reflection.Assembly.LoadFrom(guessedPath);
#endif // SHADOWCOPY
        }
    }
#endif // NETFRAMEWORK

        // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_0 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_0 instance = new BenchmarkDotNet.Autogenerated.Runnable_0(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_0()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_0.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_0.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_1 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_1 instance = new BenchmarkDotNet.Autogenerated.Runnable_1(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_1()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_1.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_1.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_2 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_2 instance = new BenchmarkDotNet.Autogenerated.Runnable_2(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_2()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_2.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_2.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_3 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_3 instance = new BenchmarkDotNet.Autogenerated.Runnable_3(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_3()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_3.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_3.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_4 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_4 instance = new BenchmarkDotNet.Autogenerated.Runnable_4(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_4()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_4.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_4.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_5 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_5 instance = new BenchmarkDotNet.Autogenerated.Runnable_5(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_5()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_5.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_5.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_6 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_6 instance = new BenchmarkDotNet.Autogenerated.Runnable_6(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_6()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_6.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_6.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_7 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_7 instance = new BenchmarkDotNet.Autogenerated.Runnable_7(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_7()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_7.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_7.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_8 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_8 instance = new BenchmarkDotNet.Autogenerated.Runnable_8(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_8()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_8.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_8.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_9 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_9 instance = new BenchmarkDotNet.Autogenerated.Runnable_9(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_9()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_9.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_9.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_10 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_10 instance = new BenchmarkDotNet.Autogenerated.Runnable_10(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_10()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_10.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_10.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_11 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_11 instance = new BenchmarkDotNet.Autogenerated.Runnable_11(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 5;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_11()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_11.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_11.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_12 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_12 instance = new BenchmarkDotNet.Autogenerated.Runnable_12(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_12()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_12.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_12.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_13 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_13 instance = new BenchmarkDotNet.Autogenerated.Runnable_13(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_13()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_13.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_13.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_14 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_14 instance = new BenchmarkDotNet.Autogenerated.Runnable_14(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_14()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_14.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_14.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_15 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_15 instance = new BenchmarkDotNet.Autogenerated.Runnable_15(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_15()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_15.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_15.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_16 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_16 instance = new BenchmarkDotNet.Autogenerated.Runnable_16(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_16()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_16.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_16.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_17 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_17 instance = new BenchmarkDotNet.Autogenerated.Runnable_17(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_17()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_17.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_17.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_18 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_18 instance = new BenchmarkDotNet.Autogenerated.Runnable_18(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_18()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_18.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_18.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_19 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_19 instance = new BenchmarkDotNet.Autogenerated.Runnable_19(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_19()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_19.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_19.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_20 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_20 instance = new BenchmarkDotNet.Autogenerated.Runnable_20(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_20()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_20.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_20.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_21 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_21 instance = new BenchmarkDotNet.Autogenerated.Runnable_21(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_21()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_21.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_21.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_22 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_22 instance = new BenchmarkDotNet.Autogenerated.Runnable_22(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_22()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_22.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_22.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_23 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_23 instance = new BenchmarkDotNet.Autogenerated.Runnable_23(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 10;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_23()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_23.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_23.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_24 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_24 instance = new BenchmarkDotNet.Autogenerated.Runnable_24(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_24()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_24.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_24.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_25 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_25 instance = new BenchmarkDotNet.Autogenerated.Runnable_25(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_25()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_25.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_25.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_26 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_26 instance = new BenchmarkDotNet.Autogenerated.Runnable_26(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_26()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_26.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_26.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_27 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_27 instance = new BenchmarkDotNet.Autogenerated.Runnable_27(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_27()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_27.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_27.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_28 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_28 instance = new BenchmarkDotNet.Autogenerated.Runnable_28(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_28()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_28.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_28.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_29 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_29 instance = new BenchmarkDotNet.Autogenerated.Runnable_29(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_29()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_29.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_29.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_30 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_30 instance = new BenchmarkDotNet.Autogenerated.Runnable_30(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_30()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_30.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_30.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_31 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_31 instance = new BenchmarkDotNet.Autogenerated.Runnable_31(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_31()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_31.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_31.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_32 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_32 instance = new BenchmarkDotNet.Autogenerated.Runnable_32(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_32()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_32.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_32.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_33 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_33 instance = new BenchmarkDotNet.Autogenerated.Runnable_33(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_33()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_33.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_33.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_34 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_34 instance = new BenchmarkDotNet.Autogenerated.Runnable_34(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_34()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_34.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_34.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_35 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_35 instance = new BenchmarkDotNet.Autogenerated.Runnable_35(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 15;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_35()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_35.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_35.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_36 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_36 instance = new BenchmarkDotNet.Autogenerated.Runnable_36(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_36()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_36.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_36.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_37 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_37 instance = new BenchmarkDotNet.Autogenerated.Runnable_37(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_37()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_37.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_37.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_38 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_38 instance = new BenchmarkDotNet.Autogenerated.Runnable_38(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 100;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_38()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_38.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_38.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_39 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_39 instance = new BenchmarkDotNet.Autogenerated.Runnable_39(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_39()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_39.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_39.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_40 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_40 instance = new BenchmarkDotNet.Autogenerated.Runnable_40(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_40()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_40.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_40.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_41 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_41 instance = new BenchmarkDotNet.Autogenerated.Runnable_41(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 200;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_41()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_41.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_41.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_42 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_42 instance = new BenchmarkDotNet.Autogenerated.Runnable_42(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_42()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_42.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_42.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_43 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_43 instance = new BenchmarkDotNet.Autogenerated.Runnable_43(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_43()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_43.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_43.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_44 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_44 instance = new BenchmarkDotNet.Autogenerated.Runnable_44(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 500;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_44()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_44.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_44.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_45 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_45 instance = new BenchmarkDotNet.Autogenerated.Runnable_45(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_45()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_45.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_45.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_46 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_46 instance = new BenchmarkDotNet.Autogenerated.Runnable_46(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Int32 OverheadDelegate();

        public delegate  System.Int32 WorkloadDelegate();

        public Runnable_46()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = RecursiveFactorial;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_46.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_46.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Int32 __Overhead() // __ is to avoid possible name conflict
        {
            return default(System.Int32);
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Int32 __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return RecursiveFactorial();
            }
            
            return default(System.Int32);
        }

    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_47 : global::BenchmarkSuite.Mather
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_47 instance = new BenchmarkDotNet.Autogenerated.Runnable_47(); // do NOT change name "instance" (used in SmartParamameter)
            instance.FactorialLimit = 20;instance.PrimeLimit = 1000;

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = false,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate System.Collections.Generic.List<System.Int32> OverheadDelegate();

        public delegate  System.Collections.Generic.List<System.Int32> WorkloadDelegate();

        public Runnable_47()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = IterativeEratosthenes;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_47.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_47.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;dummyVar++;
        }

        private System.Collections.Generic.List<System.Int32> __Overhead() // __ is to avoid possible name conflict
        {
            return null;
        }


        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public System.Collections.Generic.List<System.Int32> __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return IterativeEratosthenes();
            }
            
            return default(System.Collections.Generic.List<System.Int32>);
        }

    }
}
